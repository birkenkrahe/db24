#+STARTUP: hideblocks overview indent entitiespretty :
#+OPTIONS: toc:nil num:nil ^:nil:
#+PROPERTY: header-args:sqlite :results output
* README

- Open [[http://tinyurl.com/select-org][tinyurl.com/select-org]] to code along and save as ~select.org~

- Download the foods database as an SQL file from
  [[http://tinyurl.com/foods-sql][tinyurl.com/foods-sql]] and save it as foods.sql

- Either import the ~foods~ database from the commandline:
  #+begin_example bash
    sqlite3 foods.db < foods.sql
  #+end_example  

- Or import the database in a code block:
  #+begin_src sqlite :db foods.db :results output :header :column 
    .read ../data/foods.sql
    .database
    .tables
  #+end_src

  #+RESULTS:
  : main: /home/marcus/GitHub/db24/org/foods.db r/w
  : episodes        food_types      foods           foods_episodes

#+begin_src bash
  ls -l foods.db   # DIR foods.db
#+end_src

#+RESULTS:
: -rw-r--r-- 1 marcus marcus 40960 Mar  7 15:01 foods.db

- If we don't finish, you'll get the updated file at the start

Content:
- Overview of the =SELECT= pipeline
- Projection and restriction/filtering
- Anatomy of the =WHERE= clause
- Values and data types
- Unary, binary, and ternary operators

* =SELECT= command overview
#+attr_html: :width 700px:
[[../img/select1.png]]

- [[https://xmind.app/m/Rg5Dw8][The mindmap]] contains 91 examples but you need to open XMind
  (xmind.app) to see it, alas ([[https://github.com/birkenkrahe/db24/blob/main/img/SELECT.xmind][GitHub copy)]].

* =SELECT= pipeline overview

- Phases of =SELECT=
  #+attr_html: :width 700px:
  [[../img/select_phases.png]]

* =SELECT= column restriction (projection)

- =SELECT= is the most complex command in SQL.

- =SELECT= projects columns into a new working table.
  #+attr_html: :width 300px:
  [[../img/select_project.png]]

  #+begin_src sqlite :db ../data/foods.db :results output :header :column
    SELECT name FROM food_types;
  #+end_src

  #+RESULTS:
  #+begin_example
  name        
  ------------
  Bakery      
  Cereal      
  Chicken/Fowl
  Condiments  
  Dairy       
  Dip         
  Drinks      
  Fruit       
  Junkfood    
  Meat        
  Rice/Pasta  
  Sandwiches  
  Seafood     
  Soup        
  Vegetables  
  #+end_example

  But how many columns does this table have?
  #+begin_src sqlite :db ../data/foods.db :results output :header :column 
    .schema food_types
  #+end_src

  #+RESULTS:
  : CREATE TABLE food_types(
  :   id integer primary key,
  :   name text );

* =WHERE= row restriction (filtering)

- The =WHERE= clause is the most complex clause in =SELECT.=

- =SELECT= projects, and =WHERE= restricts the number of rows. In between,
  virtual tables R1 and R2 are created.
  #+attr_html: :width 700px:
  [[../img/select_restrict.png]]

  #+begin_src sqlite :db ../data/foods.db :results output :header :column
    SELECT name FROM foods WHERE (id=1 OR id=2); /* restriction with Boolean expression */
  #+end_src

  #+RESULTS:
  : name          
  : --------------
  : Bagels        
  : Bagels, raisin

- The argument of =WHERE= is a logical /predicate/.

- A predicate is an /assertion/ about something:
  #+begin_quote
  "The dog is purple and has a toothy grin."
  #+end_quote

  Here, ~dog~ is the *subject*, and ~"color is purple"~ and ~"grin is toothy"~
  is the *predicate*.

- The logical *subject* in the =WHERE= clause is a row.

- The =WHERE= clause is the logical *predicate*.

- How would the sentence above be translated into SQL?
  #+begin_quote
  SELECT * FROM dogs WHERE color='purple' AND grin='toothy';
  #+end_quote
  1) ~dogs~ is the table with all data about dogs
  2) ~color~ and ~grin~ are two column in ~dogs~

- This statement would filter those rows that satisfy the logical
  proposition:
  #+begin_quote
  This row has color='purple' and grin='toothy'
  #+end_quote

* Values and data types

- /Values/ represent data in in the real world.

- Values are classified by their type (numeric, string, date etc.)

- Values can be expressed as one of:

  1) *literals* (unchangeable) - like ~1~, ~2~, ~3~, "~Batesville~" etc.
     #+begin_src sqlite :db ../data/foods.db :results output :header :column
       SELECT "Batesville" AS 'City of';
     #+end_src

     #+RESULTS:
     : City of   
     : ----------
     : Batesville

     #+begin_src sqlite :db ../data/foods.db :results output :header :column
       SELECT '1,2,3' AS "numbers";
     #+end_src

     #+RESULTS:
     : numbers
     : -------
     : 1,2,3  

  2) *variables* (changeable) - e.g. column names like ~foods.name~
     #+begin_src sqlite :db ../data/foods.db :results output :header :column
       SELECT foods.name FROM foods LIMIT 2;
     #+end_src

     #+RESULTS:
     : name          
     : --------------
     : Bagels        
     : Bagels, raisin

  3) *expressions* (reducible) - e.g. ~3 + 2/5~
     #+begin_src sqlite :db ../data/foods.db :results output :column
       SELECT 3+2/5;  /* without decimal point, rounding takes place */
       SELECT 3.+2./17.;  
     #+end_src

     #+RESULTS:
     : 3    
     : 3.11764705882353
     
  4) *function results* - e.g. ~COUNT(foods.name))~
     #+begin_src sqlite :db ../data/foods.db :results output :header :column
       SELECT COUNT(foods.name) AS "No. of foods" FROM foods;
     #+end_src

     #+RESULTS:
     : No. of foods
     : ------------
     : 412         

* Operators
#+attr_html: :width 600px:
[[../img/operators.png]]

- An operator takes one or more values as input and produces a value as output.

- Unary/Binary/Ternary operators take 1/2/3 input values (operands).

- Operators can be /pipelined/ and strung together forming value expressions:
  #+begin_example
  x = count(episodes.name)
  y = count(foods.name)
  z = y/x * 11
  #+end_example

- In ~foods~, this could look like this (max 1000 subqueries in SQLite)[fn:1]:
  #+begin_src sqlite :db ../data/foods.db :results output :column 
    SELECT
    (SELECT COUNT(name) FROM foods)/
    (SELECT COUNT(name) FROM episodes) * 11;
  #+end_src

  #+RESULTS:
  : 22                                                                         

- Redo this with =REAL= numbers:
  #+begin_src sqlite :db ../data/foods.db :results output :column 
    SELECT
    ((SELECT COUNT(name) FROM foods) * 1.0 /
    (SELECT COUNT(name) FROM episodes) ) * 11.0;
  #+end_src

  #+RESULTS:
  : 25.0386740331492                                                                       

- Or you could create a temporary table ~TempResult~ to hold the result:
  #+begin_src sqlite :db ../data/foods.db :results output :header :column 
    CREATE TEMP TABLE TempResult AS
    SELECT
    ((SELECT COUNT(name) * 1.0 FROM foods) /
    (SELECT COUNT(name) FROM episodes)) * 11.0 AS result;
    .tables
    SELECT * FROM temp.TempResult;
  #+end_src

  #+RESULTS:
  : episodes         foods            temp.TempResult
  : food_types       foods_episodes 
  : result          
  : ----------------
  : 25.0386740331492

- As a Common Table Expression (CTE):
  #+begin_src sqlite :db ../data/foods.db :results output :header :column 
    WITH ComputedResult AS (
     SELECT
     ((SELECT COUNT(name) * 1.0 FROM foods) /
      (SELECT COUNT(name) FROM episodes)) * 11.0 AS result
      )
    SELECT result FROM ComputedResult;
  #+end_src

  #+RESULTS:
  : result          
  : ----------------
  : 25.0386740331492

- SQLite has a ternary operator-like structure in the =CASE= statement:
  #+begin_example sqlite
  SELECT
    CASE
      WHEN condition THEN true_value
      ELSE false_value
    END AS ResultColumn
  FROM TableName;
  #+end_example

- This SQL snippet demonstrates how to use the =CASE= statement in
  SQLite to mimic a ternary operator. It evaluates a condition for
  each row in the table ~TableName~. If the condition is true, it
  returns ~true_value~; otherwise, it returns ~false_value~ in the
  ~ResultColumn~.

- For ~foods~, we could for example check if a food type is sweet and
  print that information as a new (virtual) column ~Sweet~:
  
  #+begin_src sqlite :db foods.db :results output :header :column 
    SELECT name,
      CASE
       WHEN name='Bakery' OR name='Cereal' OR name='Fruit' THEN 'yes'
       ELSE 'no'
      END AS 'Sweet'
    FROM food_types;
  #+end_src

  #+RESULTS:
  #+begin_example
  name          Sweet
  ------------  -----
  Bakery        yes  
  Cereal        yes  
  Chicken/Fowl  no   
  Condiments    no   
  Dairy         no   
  Dip           no   
  Drinks        no   
  Fruit         yes  
  Junkfood      no   
  Meat          no   
  Rice/Pasta    no   
  Sandwiches    no   
  Seafood       no   
  Soup          no   
  Vegetables    no   
  #+end_example

- This is /ternary/ (three-way) in the sense that each row in the ~name~
  column is input, with two output possibilities depending on the =CASE.=

* Binary operators

- Binary operators (operators with two operands) are the most common
  ones. The table lists them by precedence from highest to lowest.
  #+attr_html: :width 600px:
  [[../img/binary_operators.png]]
  
* String concatenation

- String concatenation can be used to combine field values:
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT name || '(' || season || ')' AS 'Episode (#)' FROM episodes LIMIT 1,3;
  #+end_src

  #+RESULTS:
  : Episode (#)      
  : -----------------
  : Male Unbonding(1)
  : The Stake Out(1) 
  : The Robbery(1)   

- Is ~"Episode (#)~ a new table? 
#+begin_src sqlite :db test.db :results output :header :column 
  .schema
#+end_src

#+RESULTS:
#+begin_example
CREATE TABLE episodes (
  id integer primary key,
  season int,
  name text );
CREATE TABLE foods(
  id integer primary key,
  type_id integer,
  name text );
CREATE TABLE foods_episodes(
  food_id integer,
  episode_id integer );
CREATE TABLE food_types(
  id integer primary key,
  name text );
#+end_example

* Relational operators

- These operators work even without reference to any table:
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT 1 > 2-2; /* order or precedence is observed */
    SELECT 1 < 2;
    SELECT 1 == 2; /* Same result as 1 = 2 */
    SELECT 1 = 2; /* Same result as 1 == 2 */           
  #+end_src

  #+RESULTS:
  #+begin_example
  1 > 2-2
  -------
  1      
  1 < 2
  -----
  1    
  1 == 2
  ------
  0     
  1 = 2
  -----
  0    
  #+end_example

* Logical operators

- Logical operators (=AND=, =OR=, =NOT=, =IN=) are binary operators that
  operate no truth values or logical expressions. Here, like in C, any
  non-zero value is ~TRUE~.

-  What do you think ~SELECT -1 AND 1;~ will yield?
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT -1 AND 1; /* same as TRUE AND TRUE */
  #+end_src

  #+RESULTS:
  : -1 AND 1
  : --------
  : 1       

- Try ~SELECT 0 AND 1~ and ~0 OR 1~:
  #+begin_src sqlite :db test.db :results output :header :column
    SELECT 0 AND 1;            
    SELECT 0 OR 1;
  #+end_src

  #+RESULTS:
  : 0 AND 1
  : -------
  : 0      
  : 0 OR 1
  : ------
  : 1     

- Bonus assignment: prove De Morgan's laws[fn:2] using ~SELECT~:
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT NOT(1 OR 0);
    SELECT (NOT 1 AND NOT 0);       
  #+end_src

  #+RESULTS:
  : NOT(1 OR 0)
  : -----------
  : 0          
  : (NOT 1 AND NOT 0)
  : -----------------
  : 0                

- What if you wanted values in a particular range, e.g. ~id \in [3,8)~
  #+begin_src sqlite :db foods.db :results output :header :column 
    SELECT id, name FROM foods WHERE 3 <= id AND id < 8; /* id in [3,8) */
  #+end_src

  #+RESULTS:
  : id  name                   
  : --  -----------------------
  : 3   Bavarian Cream Pie     
  : 4   Bear Claws             
  : 5   Black and White cookies
  : 6   Bread (with nuts)      
  : 7   Butterfingers          

- What if you wanted values outside of the range ~id \in [3,8)~
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT id, name FROM foods WHERE  id < 3 OR 8 <= id LIMIT 5; /* id NOT in [3,8) */
  #+end_src

  #+RESULTS:
  : id  name              
  : --  ------------------
  : 1   Bagels            
  : 2   Bagels, raisin    
  : 8   Carrot Cake       
  : 9   Chips Ahoy Cookies
  : 10  Chocolate Bobka   

- What if you wanted to know if there is a ~Junkfood~ (~type_id = 9~)
  named ~JujyFruit~?
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT * FROM foods WHERE name='JujyFruit' AND type_id=9;
  #+end_src

  #+RESULTS:
  : id   type_id  name     
  : ---  -------  ---------
  : 244  9        JujyFruit

- The =IN= operator is used to check if a value matches a value in a
  list or a subquery result. For example: how many ~foods~ are chicken
  (~type_id=3~) or meat (~type_id=10~)?
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT COUNT() AS "Chicken or meat" FROM foods WHERE type_id IN (3,10);
  #+end_src

  #+RESULTS:
  : Chicken or meat
  : ---------------
  : 59             

* The =LIKE= and =GLOB= operators

- The =LIKE= operator is used to match string values against patterns
  (like =grep=).

- Say you wanted to know all ~foods~ whose name begins with a ~J~:
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT id, name FROM foods WHERE name LIKE 'J%';
  #+end_src

  #+RESULTS:
  : id   name              
  : ---  ------------------
  : 156  Juice box         
  : 236  Jucyfruit Gum     
  : 243  Jello with Bananas
  : 244  JujyFruit         
  : 245  Junior Mints      
  : 370  Jambalaya         

- Here, a percent symbol =%= matches any sequence of zero or more
  characters in the string.

- An underscore symbol ~_~ matches any single character in the string.

- Example: find all ~foods~ that have ~ac~ and ~P~ somewhere in the ~name~.
  #+begin_src sqlite :db test.db :results output :header :column
    SELECT id, name FROM foods WHERE name LIKE '%ac%P%';
  #+end_src

  #+RESULTS:
  : id   name                
  : ---  --------------------
  : 38   Pie (Blackberry) Pie
  : 127  Guacamole Dip       
  : 168  Peach Schnapps      
  : 198  Macinaw peaches     

- If you remove the last =%= sign, you're only looking for ~foods~ that
  also end in ~p~ or ~P.~

- =LIKE= is not case-sensitive in all SQL flavors. In SQLite, you can
  switch case sensitivity on (=PRAGMA case_sensitive_like=ON=):
  #+begin_src sqlite :db test.db :results output :header :column
    PRAGMA case_sensitive_like=OFF;  /* Values are ON or OFF */
    SELECT id, name FROM foods WHERE name LIKE '%ac%P%';
  #+end_src

  #+RESULTS:
  : id   name                
  : ---  --------------------
  : 38   Pie (Blackberry) Pie
  : 127  Guacamole Dip       
  : 168  Peach Schnapps      
  : 198  Macinaw peaches     

- A useful trick is NOT to negate a pattern: for example, if you did
  not want ~foods~ with ~Sch~ in the name (excludes German/Dutch foods):
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT id, name FROM foods
    WHERE name LIKE '%ac%P%' AND name NOT LIKE '%Sch%';
    #+end_src

  #+RESULTS:
  : id   name                
  : ---  --------------------
  : 38   Pie (Blackberry) Pie
  : 127  Guacamole Dip       
  : 198  Macinaw peaches     

- In Unix/Linux, /globbing/ refers to auto-completion for example when
  searching for files beginning with ~hello~ using a wildcard: ~ls -l
  hello*~.

  #+begin_src bash :results output
    ls -l foo*
  #+end_src

  #+RESULTS:
  : -rw-r--r-- 1 marcus marcus 40960 Mar  7 15:01 foods.db
  : -rw-rw-r-- 1 marcus marcus   903 Feb 13 18:50 foods.org

- The =GLOB= operator uses wildcards like ~*~ and ~_~ and matching is cas
  sensitive:
  #+begin_src sqlite :db test.db :results output :header :column
    /* match all rows whose `name` begins with `Pine` */            
    SELECT id, name FROM foods WHERE name GLOB 'Pine*'; 
  #+end_src

- You can get very creative if you know, like and use regular
  expressions. SQLite does not provide native implementations but you
  can develop your own using the =sqlite_create_function()= API call
  ([[https://sqlite.org/appfunc.html][read more]]).

* Limiting and ordering

- You can limit size and range of the result with =LIMIT= and =OFFSET=:
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT * FROM food_types ORDER BY id LIMIT 1 OFFSET 1;
  #+end_src

  #+RESULTS:
  : id  name  
  : --  ------
  : 2   Cereal

- The =OFFSET= clause skips one row (~Bakery~), and the =LIMIT= clause
  returns a maximum of one row (~Cereal~). They come last in the
  pipeline.

- The =ORDER BY= clause sorts the result by a column or columns before
  it is returned.

- This is essential because the rows returned from =SELECT= are never
  guaranteed to be in a specific order (this is part of the SQL
  standard).

- In other words: you need =ORDER BY= if you need to count on the result
  being in any specific order.

- THe =ORDER BY= clause is similar to =SELECT=: it takes an ordered,
  comma-separated list of column. After each column name, you can
  specify if you want ascending (=ASC= default) or descending (=DESC=)
  order.

- Example: extract all rows whose ~food~ names start with a ~B~, and then
  order them in descending food ~type_id~ order. Return only 10 results.
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT * FROM foods WHERE NAME LIKE 'B%'
           ORDER BY type_id DESC, name LIMIT 10;
  #+end_src

- You can see that the ~type_id~ column is order in descending
  order. Within each group of identical food types, the food ~name~ is
  ordered in ascending order (by default).

- Challenge: show the ~foods~ that start with C and order them in
  ascending order by type, but in descending order by name.
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT * FROM foods WHERE NAME LIKE 'C%'
           ORDER BY type_id, name DESC LIMIT 10;
  #+end_src

  #+RESULTS:
  #+begin_example
  id  type_id  name               
  --  -------  -------------------
  18  1        Cupcakes           
  17  1        Cupcake            
  16  1        Crackers           
  15  1        Cookie             
  14  1        Cinnamon Swirls    
  13  1        Cinnamon Bobka     
  11  1        Chocolate Eclairs  
  12  1        Chocolate Cream Pie
  10  1        Chocolate Bobka    
  9   1        Chips Ahoy Cookies 
  #+end_example

- If you use both =LIMIT= and =OFFSET= together, you can use a comma
  notation in place of the =OFFSET= keyword:
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT * FROM foods WHERE NAME LIKE 'B%'
           ORDER BY type_id DESC, name LIMIT 2,1; /* display 2nd row of result only */
  #+end_src

  #+RESULTS:
  : id   type_id  name     
  : ---  -------  ---------
  : 384  15       Big Salad

* COUNT

- How many junkfoods are there?
  #+begin_src sqlite :db test.db :results output :header :column 
    SELECT DISTINCT COUNT() FROM foods WHERE type_id=9;
           SELECT id,name from food_types;
  #+end_src

  #+RESULTS:
  #+begin_example
  COUNT()
  -------
  61     
  id  name        
  --  ------------
  1   Bakery      
  2   Cereal      
  3   Chicken/Fowl
  4   Condiments  
  5   Dairy       
  6   Dip         
  7   Drinks      
  8   Fruit       
  9   Junkfood    
  10  Meat        
  11  Rice/Pasta  
  12  Sandwiches  
  13  Seafood     
  14  Soup        
  15  Vegetables  
  #+end_example
  
* Footnotes
[fn:2] The negation of a disjunction is the conjunction of the
negations, and the negation of a conjunction is the disjunction of the
negations.

[fn:1] In SQLite, the set parameter ~SQLITE_MAX_EXPR_DEPTH~ is 1000, not
9, and it's not just for nested SELECT queries but for the whole
expression tree ([[https://sqlite.org/limits.html][source]]). For other flavors, the values are all over
the place: SQL Server = 32 nested subqueries, Oracle = 255, and
another source said "There is no limit to the number of subqueries you
can use in an SQL query." MySQL and PostgreSQL have a ~thread_stack~
parameter that can be set freely. Either way, these set values can be
changed at runtime.
