#+STARTUP: hideblocks overview indent :
#+OPTIONS: toc:nil num:nil ^:nil:
#+PROPERTY: header-args:sqlite :results output
* README

- Open [[http://tinyurl.com/select-org][tinyurl.com/select-org]] to code along and save as ~select.org~

- Download the foods database as an SQL file from
  [[http://tinyurl.com/foods-sql][tinyurl.com/foods-sql]] and save it as foods.sql

- Either import the ~foods~ database from the commandline:
  #+begin_example bash
    sqlite3 foods.db < foods.sql
  #+end_example  

- Or import the database in a code block:
  #+begin_src sqlite :db foods.db :results output :header :column 
    .read ../data/foods.sql
    .database
    .tables
  #+end_src

  #+RESULTS:
  : main: /home/marcus/GitHub/db24/org/foods.db r/w
  : episodes        food_types      foods           foods_episodes

#+begin_src bash
  ls -l foods.db   # DIR foods.db
#+end_src

#+RESULTS:
: -rw-r--r-- 1 marcus marcus 40960 Mar  7 15:01 foods.db

- If we don't finish, you'll get the updated file at the start

Content:
- Overview of the =SELECT= pipeline
- Projection and restriction/filtering
- Anatomy of the =WHERE= clause
- Values and data types
- Unary, binary, and ternary operators

* =SELECT= command overview
#+attr_html: :width 700px:
[[../img/select1.png]]

- [[https://xmind.app/m/Rg5Dw8][The mindmap]] contains 91 examples but you need to open XMind
  (xmind.app) to see it, alas ([[https://github.com/birkenkrahe/db24/blob/main/img/SELECT.xmind][GitHub copy)]].

* =SELECT= pipeline overview

- Phases of =SELECT=
  #+attr_html: :width 700px:
  [[../img/select_phases.png]]

* =SELECT= column restriction (projection)

- =SELECT= is the most complex command in SQL.

- =SELECT= projects columns into a new working table.
  #+attr_html: :width 300px:
  [[../img/select_project.png]]

  #+begin_src sqlite :db ../data/foods.db :results output :header :column
    SELECT name FROM food_types;
  #+end_src

  #+RESULTS:
  #+begin_example
  name        
  ------------
  Bakery      
  Cereal      
  Chicken/Fowl
  Condiments  
  Dairy       
  Dip         
  Drinks      
  Fruit       
  Junkfood    
  Meat        
  Rice/Pasta  
  Sandwiches  
  Seafood     
  Soup        
  Vegetables  
  #+end_example

  But how many columns does this table have?
  #+begin_src sqlite :db ../data/foods.db :results output :header :column 
    .schema food_types
  #+end_src

  #+RESULTS:
  : CREATE TABLE food_types(
  :   id integer primary key,
  :   name text );

* =WHERE= row restriction (filtering)

- The =WHERE= clause is the most complex clause in =SELECT.=

- =SELECT= projects, and =WHERE= restricts the number of rows. In between,
  virtual tables R1 and R2 are created.
  #+attr_html: :width 700px:
  [[../img/select_restrict.png]]

  #+begin_src sqlite :db ../data/foods.db :results output :header :column
    SELECT name FROM foods WHERE (id=1 OR id=2); /* restriction with Boolean expression */
  #+end_src

- The argument of =WHERE= is a logical /predicate/.

- A predicate is an /assertion/ about something:
  #+begin_quote
  "The dog is purple and has a toothy grin."
  #+end_quote

  Here, ~dog~ is the *subject*, and ~"color is purple"~ and ~"grin is toothy"~
  is the *predicate*.

- The logical *subject* in the =WHERE= clause is a row.

- The =WHERE= clause is the logical *predicate*.

- How would the sentence above be translated into SQL?
  #+begin_quote
  SELECT * FROM dogs WHERE color='purple' AND grin='toothy';
  #+end_quote
  1) ~dogs~ is the table with all data about dogs
  2) ~color~ and ~grin~ are two column in ~dogs~

- This statement would filter those rows that satisfy the logical
  proposition:
  #+begin_quote
  This row has color='purple' and grin='toothy'
  #+end_quote

* Values and data types

- /Values/ represent data in in the real world.

- Values are classified by their type (numeric, string, date etc.)

- Values can be expressed as one of:

  1) *literals* (unchangeable) - like ~1~, ~2~, ~3~, "~Batesville~" etc.
     #+begin_src sqlite :db ../data/foods.db :results output :header :column
       SELECT "Batesville" AS 'City of';
     #+end_src

     #+RESULTS:
     : City of   
     : ----------
     : Batesville

     #+begin_src sqlite :db ../data/foods.db :results output :header :column
       SELECT '1,2,3' AS "numbers";
     #+end_src

     #+RESULTS:
     : numbers
     : -------
     : 1,2,3  

  2) *variables* (changeable) - e.g. column names like ~foods.name~
     #+begin_src sqlite :db ../data/foods.db :results output :header :column
       SELECT foods.name FROM foods LIMIT 2;
     #+end_src

     #+RESULTS:
     : name          
     : --------------
     : Bagels        
     : Bagels, raisin

  3) *expressions* (reducible) - e.g. ~3 + 2/5~
     #+begin_src sqlite :db ../data/foods.db :results output :column
       SELECT 3+2/5;  /* without decimal point, rounding takes place */
       SELECT 3.+2./17.;  
     #+end_src

     #+RESULTS:
     : 3    
     : 3.11764705882353
     
  4) *function results* - e.g. ~COUNT(foods.name))~
     #+begin_src sqlite :db ../data/foods.db :results output :header :column
       SELECT COUNT(foods.name) AS "No. of foods" FROM foods;
     #+end_src

     #+RESULTS:
     : No. of foods
     : ------------
     : 412         

* Operators
#+attr_html: :width 600px:
[[../img/operators.png]]

- An operator takes one or more values as input and produces a value as output.

- Unary/Binary/Ternary operators take 1/2/3 input values (operands).

- Operators can be /pipelined/ and strung together forming value expressions:
  #+begin_example
  x = count(episodes.name)
  y = count(foods.name)
  z = y/x * 11
  #+end_example

- In ~foods~, this could look like this (max 1000 subqueries in SQLite)[fn:1]:
  #+begin_src sqlite :db ../data/foods.db :results output :column 
    SELECT
       (SELECT COUNT(name) FROM foods)/
       (SELECT COUNT(name) FROM episodes) * 11;
  #+end_src

  #+RESULTS:
  : 22                                                                         

- Redo this with =REAL= numbers:
  #+begin_src sqlite :db ../data/foods.db :results output :column 
    SELECT
       ((SELECT COUNT(name) FROM foods) * 1.0 /
       (SELECT COUNT(name) FROM episodes) ) * 11.0;
  #+end_src

  #+RESULTS:
  : 25.0386740331492                                                                       

- Or you could create a temporary table ~TempResult~ to hold the result:
  #+begin_src sqlite :db ../data/foods.db :results output :header :column 
    CREATE TEMP TABLE TempResult AS
    SELECT
      ((SELECT COUNT(name) * 1.0 FROM foods) /
       (SELECT COUNT(name) FROM episodes)) * 11.0 AS result;
    .tables
    SELECT * FROM temp.TempResult;
  #+end_src

  #+RESULTS:
  : episodes         foods            temp.TempResult
  : food_types       foods_episodes 
  : result          
  : ----------------
  : 25.0386740331492

- As a Common Table Expression (CTE):
  #+begin_src sqlite :db ../data/foods.db :results output :header :column 
    WITH ComputedResult AS (
      SELECT
       ((SELECT COUNT(name) * 1.0 FROM foods) /
        (SELECT COUNT(name) FROM episodes)) * 11.0 AS result
        )
    SELECT result FROM ComputedResult;
  #+end_src

  #+RESULTS:
  : result          
  : ----------------
  : 25.0386740331492

* Footnotes

[fn:1] In SQLite, the set parameter ~SQLITE_MAX_EXPR_DEPTH~ is 1000, not
9, and it's not just for nested SELECT queries but for the whole
expression tree ([[https://sqlite.org/limits.html][source]]). For other flavors, the values are all over
the place: SQL Server = 32 nested subqueries, Oracle = 255, and
another source said "There is no limit to the number of subqueries you
can use in an SQL query." MySQL and PostgreSQL have a ~thread_stack~
parameter that can be set freely. Either way, these set values can be
changed at runtime.
